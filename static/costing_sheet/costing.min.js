// static/costing_sheet/costing.js
// Robust, tolerant script to populate sizes and autofill costing fields
// - Uses embedded master_data if present
// - Falls back to AJAX endpoints
// - Tolerant about input ids/names and many possible JSON key names
(function () {
  "use strict";

  /* ---------- small utilities ---------- */
  function dbg() { if (window && window.console) console.log.apply(console, ["[costing.js]"].concat(Array.from(arguments))); }
  function err() { if (window && window.console) console.error.apply(console, ["[costing.js]"].concat(Array.from(arguments))); }
  function $(id) { return document.getElementById(id); }
  function q(sel) { try { return document.querySelector(sel); } catch (e) { return null; } }
  function numeric(v) { var n = Number(v); return isNaN(n) ? 0 : n; }
  function fmt2(v) { return (Number(v) || 0).toFixed(2); }
  function fmt4(v) { return (Number(v) || 0).toFixed(4); }

  function parseJSONFromEl(id) {
    try {
      var el = document.getElementById(id);
      if (!el) return null;
      var txt = el.textContent || el.innerText || "";
      if (!txt) return null;
      return JSON.parse(txt);
    } catch (e) {
      err("parseJSONFromEl", id, e);
      return null;
    }
  }

  function parseConfig() {
    try {
      var cfg = parseJSONFromEl("costing-config");
      if (cfg) return cfg;
    } catch (e) {}
    return {
      ajax_sizes: "/costing/ajax/sizes/",
      ajax_category_details: "/costing/ajax/category-details/"
    };
  }

  var master = parseJSONFromEl("costing-master"); // may be null
  var cfg = parseConfig();

  function ajaxGet(url, cb) {
    dbg("AJAX GET:", url);
    fetch(url, { credentials: "same-origin", headers: { "Accept": "application/json" } })
      .then(function (r) { if (!r.ok) throw new Error("HTTP " + r.status); return r.json(); })
      .then(function (j) { dbg("AJAX resp", url, j); cb && cb(j); })
      .catch(function (e) { err("AJAX error", url, e); cb && cb(null, e); });
  }

  /* ---------- DOM refs (try a few common ids/selectors) ---------- */
  var categorySelect = $("id_category_select") || document.querySelector("select[name='category']") || q("select#category");
  var sizeSelect = $("id_size_select") || document.querySelector("select[name='size']") || q("select#size");
  var sizeInfoBox = $("id_size_meta") || $("size-category-info") || q(".size-meta");

  // visible stitching/finishing/packaging fields (if any)
  var el_stitch = $("id_stitching_cost") || q("input[name='stitching_cost']");
  var el_finish = $("id_finishing_cost") || q("input[name='finishing_cost']");
  var el_pack = $("id_packaging_cost") || q("input[name='packaging_cost']");

  // Generic setter: try element by id(s), by name, or by class
  function setInputValue(candidates, value, formatFn) {
    if (!candidates || !candidates.length) return false;
    var val = (typeof formatFn === "function") ? formatFn(value) : (value == null ? "" : String(value));
    var setSomething = false;
    for (var i = 0; i < candidates.length; i++) {
      var id = candidates[i];
      if (!id) continue;
      // try id first
      var el = document.getElementById(id);
      if (el) {
        if (el.tagName.toLowerCase() === "input" || el.tagName.toLowerCase() === "textarea" || el.tagName.toLowerCase() === "select") {
          el.value = val;
        } else {
          el.textContent = val;
        }
        setSomething = true;
        continue;
      }
      // try name selector
      var byName = document.querySelector("[name='" + id + "']");
      if (byName) {
        if (byName.tagName.toLowerCase() === "input" || byName.tagName.toLowerCase() === "textarea" || byName.tagName.toLowerCase() === "select") {
          byName.value = val;
        } else {
          byName.textContent = val;
        }
        setSomething = true;
        continue;
      }
      // try class selector (first match)
      var byClass = document.querySelector("." + id);
      if (byClass) {
        if (byClass.tagName.toLowerCase() === "input" || byClass.tagName.toLowerCase() === "textarea" || byClass.tagName.toLowerCase() === "select") {
          byClass.value = val;
        } else {
          byClass.textContent = val;
        }
        setSomething = true;
        continue;
      }
    }
    return setSomething;
  }

  /* ---------- logical keys -> possible source names and target element ids ---------- */
  var sourceKeyCandidates = {
    gf_percent: ["gf_percent", "gf", "gross_factory_percent", "gf_percent_value", "GF", "gfPercent"],
    texas_buying_percent: ["texas_buying_percent", "texas_buying", "tx_buying_percent", "texasBuyingPercent"],
    texas_retail_percent: ["texas_retail_percent", "texas_retail", "tx_retail_percent", "texasRetailPercent"],
    shipping_inr: ["shipping_inr", "shipping", "shipping_cost_inr", "ship_inr", "shipping_inr_value"],
    tx_to_us_percent: ["tx_to_us_percent", "tx_to_us", "tx_to_us_pct", "txToUsPercent"],
    import_percent: ["import_percent", "import_pct", "import_duty_percent", "importPercent"],
    new_tariff_percent: ["new_tariff_percent", "new_tariff", "tariff_percent", "newTariff"],
    recip_tariff_percent: ["reciprocal_tariff_percent", "recip_tariff_percent", "reciprocal_tariff", "recip_tariff"],
    ship_us_percent: ["ship_us_percent", "ship_us", "shipping_us_percent", "shipUsPercent"],
    us_wholesale: ["us_wholesale", "us_wholesale_price", "us_wholesale_percent", "us_wholesale_value", "usWholesale"]
  };

  // For each logical key we try a set of target element ids/names/classes (display + hidden)
  var targetElements = {
    gf_percent: ["id_gf_percent_display", "id_gf_percent", "gf_percent", "gfPercent", "gf-percent"],
    texas_buying_percent: ["id_texas_buying_percent_display", "id_texas_buying_percent", "texas_buying_percent", "texasBuying"],
    texas_retail_percent: ["id_texas_retail_percent_display", "id_texas_retail_percent", "texas_retail_percent"],
    shipping_inr: ["id_shipping_inr_display", "id_shipping_inr", "shipping_inr", "shipping_inr_display"],
    tx_to_us_percent: ["id_tx_to_us_percent_display", "id_tx_to_us_percent", "tx_to_us_percent"],
    import_percent: ["id_import_percent_display", "id_import_percent", "import_percent"],
    new_tariff_percent: ["id_new_tariff_percent_display", "id_new_tariff_percent", "new_tariff_percent"],
    recip_tariff_percent: ["id_recip_tariff_percent_display", "id_recip_tariff_percent", "recip_tariff_percent"],
    ship_us_percent: ["id_ship_us_percent_display", "id_ship_us_percent", "ship_us_percent"],
    us_wholesale: ["id_us_wholesale_display", "id_us_wholesale", "us_wholesale"]
  };

  /* ---------- helpers to read a value from a source object using many possible keys ---------- */
  function readFromSource(src, candidates) {
    if (!src || !candidates || !candidates.length) return undefined;
    for (var i = 0; i < candidates.length; i++) {
      var k = candidates[i];
      if (k in src) {
        return src[k];
      }
      // try case-insensitive keys
      for (var p in src) {
        if (String(p || "").toLowerCase() === String(k || "").toLowerCase()) {
          return src[p];
        }
      }
    }
    return undefined;
  }

  /* ---------- populate sizes (from master or AJAX) ---------- */
  function clearSelect(sel, placeholder) {
    if (!sel) return;
    sel.innerHTML = "";
    var o = document.createElement("option");
    o.value = "";
    o.text = placeholder || "-- select --";
    sel.appendChild(o);
  }
  function addSizeOption(sel, value, label, data) {
    if (!sel) return;
    var o = document.createElement("option");
    o.value = value;
    o.text = label;
    if (data && typeof data === "object") {
      Object.keys(data).forEach(function (k) {
        try { o.dataset[k] = data[k]; } catch (e) {}
      });
    }
    sel.appendChild(o);
  }

  function populateSizesFromMaster(catObj) {
    if (!sizeSelect || !catObj) return;
    clearSelect(sizeSelect, "-- select size --");
    if (!master || !master.sizes_by_category) return;
    var key = String(catObj.id);
    var arr = master.sizes_by_category[key] || master.sizes_by_category["none"] || [];
    if (!Array.isArray(arr)) return;
    arr.forEach(function (s) {
      var id = s.id || s.pk || s.size || s.name;
      var label = s.size || s.name || String(id);
      var d = {
        stitchingCost: s.stitching_cost || s.stitching || "",
        finishingCost: s.finishing_cost || s.finishing || "",
        packagingCost: s.packaging_cost || s.packaging || ""
      };
      addSizeOption(sizeSelect, id, label, d);
    });
  }

  /* ---------- fill fields from a source (category or component row) ---------- */
  function fillFieldsFromSource(src) {
    if (!src) return;
    // for each logical key, read value from src and set into possible target elements
    Object.keys(sourceKeyCandidates).forEach(function (logicalKey) {
      var candidates = sourceKeyCandidates[logicalKey];
      var raw = readFromSource(src, candidates);
      // fallback to some nested structures (e.g., src.data.gf)
      if (raw === undefined && src.data) {
        raw = readFromSource(src.data, candidates);
      }
      // choose format (shipping as 2dp, others as 4dp)
      var fmt = (logicalKey === "shipping_inr") ? fmt2 : fmt4;
      setInputValue(targetElements[logicalKey] || [], raw, fmt);
    });
  }

  /* ---------- event handlers ---------- */
  function onCategoryChange(ev) {
    var catVal = (ev && ev.target && ev.target.value) || (categorySelect ? categorySelect.value : "");
    dbg("category changed ->", catVal);
    // reset visible sizes & fields
    clearSelect(sizeSelect, "-- select size --");
    if (el_stitch) el_stitch.value = "0.00";
    if (el_finish) el_finish.value = "0.00";
    if (el_pack) el_pack.value = "0.00";
    // clear target fields
    Object.keys(targetElements).forEach(function (k) { setInputValue(targetElements[k], "", function () { return ""; }); });

    if (!catVal) {
      if (sizeInfoBox) sizeInfoBox.innerHTML = "<small class='text-muted'>Select a category to load sizes.</small>";
      return;
    }

    // prefer embedded master_data
    if (master && Array.isArray(master.categories)) {
      // try find by id or name
      var found = null;
      // try id match
      for (var i = 0; i < master.categories.length; i++) {
        var c = master.categories[i];
        if (c.id != null && String(c.id) === String(catVal)) { found = c; break; }
      }
      // try name match
      if (!found) {
        var needle = String(catVal || "").trim().toLowerCase();
        for (i = 0; i < master.categories.length; i++) {
          var c2 = master.categories[i];
          if (String(c2.name || "").trim().toLowerCase() === needle) { found = c2; break; }
        }
      }
      if (found) {
        dbg("found category in master:", found);
        // populate sizes from master
        populateSizesFromMaster(found);
        // fill fields from category object
        fillFieldsFromSource(found);
        if (sizeInfoBox) {
          try {
            sizeInfoBox.innerHTML = "<strong>Category:</strong> " + (found.name || "") + (found.description ? ("<br/><small>" + (found.description || "") + "</small>") : "");
          } catch (e) {}
        }
        return;
      }
    }

    // fallback to AJAX sizes endpoint
    var url = cfg.ajax_sizes + "?category_id=" + encodeURIComponent(catVal);
    ajaxGet(url, function (payload, err) {
      if (err || !payload) { err("sizes fetch failed", err); return; }
      var sizes = payload.sizes || payload.results || payload.items || [];
      if (Array.isArray(sizes) && sizes.length) {
        sizes.forEach(function (s) {
          var id = s.id || s.pk || s.name || s.size;
          var label = s.size || s.name || String(id);
          var ds = {
            stitchingCost: s.stitching_cost || s.stitching || "",
            finishingCost: s.finishing_cost || s.finishing || "",
            packagingCost: s.packaging_cost || s.packaging || ""
          };
          addSizeOption(sizeSelect, id, label, ds);
        });
      }
      // if payload contains category metadata, fill fields from it
      if (payload.category) {
        fillFieldsFromSource(payload.category);
        if (sizeInfoBox) {
          try { sizeInfoBox.innerHTML = "<strong>Category:</strong> " + (payload.category.name || ""); } catch (e) {}
        }
      }
    });
  }

  function onSizeChange(ev) {
    var sizeVal = (ev && ev.target && ev.target.value) || (sizeSelect ? sizeSelect.value : "");
    var catVal = categorySelect ? categorySelect.value : "";
    dbg("size changed ->", sizeVal, "for category", catVal);

    // apply dataset of selected size option to stitching/finishing/packaging
    try {
      var opt = sizeSelect && sizeSelect.options[sizeSelect.selectedIndex];
      if (opt && opt.dataset) {
        if (el_stitch && opt.dataset.stitchingcost) el_stitch.value = fmt2(opt.dataset.stitchingcost);
        if (el_finish && opt.dataset.finishingcost) el_finish.value = fmt2(opt.dataset.finishingcost);
        if (el_pack && opt.dataset.packagingcost) el_pack.value = fmt2(opt.dataset.packagingcost);
      }
    } catch (e) { dbg("apply size dataset failed", e); }

    // If embedded master exists, we already filled category-level fields on category change.
    // If you want size-specific overrides, you can look up master.sizes_by_category[cat][sizeIndex]
    if (master && master.sizes_by_category) {
      var catObj = null;
      if (master.categories && Array.isArray(master.categories)) {
        for (var i = 0; i < master.categories.length; i++) {
          var c = master.categories[i];
          if (String(c.id) === String(catVal) || String(c.name || "").toLowerCase() === String(catVal || "").toLowerCase()) {
            catObj = c;
            break;
          }
        }
      }
      if (catObj) {
        // fill from category (keeps consistent)
        fillFieldsFromSource(catObj);
        return;
      }
    }

    // fallback: request category-details (which may include components array)
    if (!catVal) return;
    var url = cfg.ajax_category_details + "?category_id=" + encodeURIComponent(catVal);
    if (sizeVal) url += "&size_id=" + encodeURIComponent(sizeVal);
    ajaxGet(url, function (payload, err) {
      if (err || !payload) { err("category-details fetch failed", err); return; }
      // try payload.category first
      if (payload.category) {
        fillFieldsFromSource(payload.category);
        return;
      }
      // else try first component row (if any)
      var rows = payload.components || payload.rows || payload;
      if (Array.isArray(rows) && rows.length) {
        fillFieldsFromSource(rows[0]);
      }
    });
  }

  /* ---------- wire events & init ---------- */
  if (categorySelect) {
    categorySelect.addEventListener("change", onCategoryChange);
    dbg("wired categorySelect");
  } else dbg("categorySelect not found");

  if (sizeSelect) {
    sizeSelect.addEventListener("change", onSizeChange);
    dbg("wired sizeSelect");
  } else dbg("sizeSelect not found");

  function init() {
    // trigger pre-population if values are prefilled
    if (categorySelect && categorySelect.value) {
      setTimeout(function () { categorySelect.dispatchEvent(new Event("change")); }, 20);
    }
    if (sizeSelect && sizeSelect.value) {
      setTimeout(function () { sizeSelect.dispatchEvent(new Event("change")); }, 200);
    }
    dbg("costing.js initialized - master present?", !!master);
  }
  init();

  // expose for debugging
  window.CostingSheet = window.CostingSheet || {};
  window.CostingSheet.debug = function () { dbg("master:", master); };
})();
